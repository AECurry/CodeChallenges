//  🏔️ MTECH Code Challenge SF38: "Merge Sort & Sorting Summary"
//  Concept: Review sorting algorithms and demonstrate a base level understanding of time complexity.

//  Instructions:
    //  Do some research on Merge Sort: 🔗https://en.wikipedia.org/wiki/Merge_sort
    //  Why is this sort more efficient than the other sorts we have learned?
    //  Why would we have you learn about sorting algorithms when there is a perfectly good .sort() function?
    //  Explain your answer in the /* */ comment marks below.

//  ⌺ Black Diamond Challenge:
    //  Include extra relevant information you learned in the black diamond challenges in your writing below.
    //  If you have not completed the other black diamond challenges, do those instead.

// MARK: Your response:

/*
 Merge Sorts are more efficient because...
• It runs in O(n log n) time consistently — even in the worst case.
• Simpler sorts (like bubble or insertion) slow down badly on big data sets (O(n²)).
• It uses a “divide and conquer” approach: split, sort, then merge — which makes it predictable and stable.
• It’s especially useful for large data, linked lists, and situations where stability matters.

 
 We need to learn about sorting algorithms so that...
 
• We understand what’s happening under the hood of functions like .sort().
• We can choose the right algorithm depending on the problem (speed, memory, stability, data size).
• It teaches us problem-solving patterns (like divide and conquer) that apply far beyond sorting.
• Relying only on .sort() is fine most of the time, but knowing the “why” and “how” makes us better programmers.
*/
