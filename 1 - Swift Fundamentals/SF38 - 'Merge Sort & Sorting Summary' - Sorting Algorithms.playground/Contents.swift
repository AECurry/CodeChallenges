//  ğŸ”ï¸ MTECH Code Challenge SF38: "Merge Sort & Sorting Summary"
//  Concept: Review sorting algorithms and demonstrate a base level understanding of time complexity.

//  Instructions:
    //  Do some research on Merge Sort: ğŸ”—https://en.wikipedia.org/wiki/Merge_sort
    //  Why is this sort more efficient than the other sorts we have learned?
    //  Why would we have you learn about sorting algorithms when there is a perfectly good .sort() function?
    //  Explain your answer in the /* */ comment marks below.

//  âŒº Black Diamond Challenge:
    //  Include extra relevant information you learned in the black diamond challenges in your writing below.
    //  If you have not completed the other black diamond challenges, do those instead.

// MARK: Your response:

/*
 Merge Sorts are more efficient because...
â€¢ It runs in O(n log n) time consistently â€” even in the worst case.
â€¢ Simpler sorts (like bubble or insertion) slow down badly on big data sets (O(nÂ²)).
â€¢ It uses a â€œdivide and conquerâ€ approach: split, sort, then merge â€” which makes it predictable and stable.
â€¢ Itâ€™s especially useful for large data, linked lists, and situations where stability matters.

 
 We need to learn about sorting algorithms so that...
 
â€¢ We understand whatâ€™s happening under the hood of functions like .sort().
â€¢ We can choose the right algorithm depending on the problem (speed, memory, stability, data size).
â€¢ It teaches us problem-solving patterns (like divide and conquer) that apply far beyond sorting.
â€¢ Relying only on .sort() is fine most of the time, but knowing the â€œwhyâ€ and â€œhowâ€ makes us better programmers.
*/
